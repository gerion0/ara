from dataclasses import dataclass
import json
import graph_tool
from typing import Any, List
from .step import Step


class MissingInteractions:
    """An os model may register missing interactions in this static class.

    Registered interactions will be accumulated and included in the data generated by InstanceGraphStats
    if the os model called activate() once in the runtime.
    """
    in_use = False  # is this class activated
    undetected = 0  # count of edges with undetected target instance
    missing = {}    # structure that maps target_instance -> InteractionData (contains specific counters)

    @dataclass
    class Counter:
        count: int  # count missing interactions with respect to edge filtering in connect_instances()
        count_without_edge_filter: int # count missing interactions without edge filtering

    @dataclass
    class InteractionData:
        normal: Any     # counters for missing interactions with unique target_instance [of type: MissingInteractions.Counter]
        imprecise: Any  # counters for missing interactions with ambiguous aimInstances [MissingInteractions.Counter]
        abb_list: List  # list of used syscall abbs for this instance. Used to count with edge filter.

    def _add(target_instance: str, abb: graph_tool.Vertex, counter_field: str):
        if target_instance not in MissingInteractions.missing:
            MissingInteractions.missing[target_instance] = MissingInteractions.InteractionData(
                                                            MissingInteractions.Counter(0, 0),
                                                            MissingInteractions.Counter(0, 0), [abb])
            field = getattr(MissingInteractions.missing[target_instance], counter_field)
            field.count = 1
            field.count_without_edge_filter = 1
        else:
            field = getattr(MissingInteractions.missing[target_instance], counter_field)
            field.count_without_edge_filter += 1
            if abb in MissingInteractions.missing[target_instance].abb_list:
                return
            MissingInteractions.missing[target_instance].abb_list.append(abb)
            field.count += 1

    def activate():
        """Activate counting of missing interactions"""
        MissingInteractions.in_use = True

    def add(target_instance: str, syscall_abb: graph_tool.Vertex):
        """Add missing interaction.

        Arguments:
        target_instance    -- Proposed target instance of this missing edge as string
        syscall_abb        -- abb of the syscall that is creating this missing edge
        """
        MissingInteractions._add(target_instance, syscall_abb, "normal")

    def add_imprecise(target_instances: List, syscall_abb: graph_tool.Vertex):
        """Add missing interaction on which the target instance is not uniquely determinable.

        For interactions on which no target is determinable, call add_undetected()

        Arguments:
        target_instances   -- Proposed target instances of this missing edge (should contain at least two target instances as strings)
        syscall_abb        -- abb of the syscall that is creating this missing edge
        """
        for instance in target_instances:
            MissingInteractions._add(instance, syscall_abb, "imprecise")

    def add_undetected():
        """Add interaction with no determinable target instance"""
        MissingInteractions.undetected += 1


class InstanceGraphStats(Step):
    """Gather statistics about the Instance Graph."""

    def get_single_dependencies(self):
        return ["InteractionAnalysis"]

    def _get_edge_type_str(self, edge_type: int):
        """Convert edge type property field to a meaningful string"""
        if not hasattr(self._graph.os, "EdgeType"):
            return "interaction"
        return self._graph.os.EdgeType(edge_type).name

    def _write_failing_interaction_syscalls_to_file(self):
        """Write file and line of all failing interaction syscalls grouped by instance type to file"""
        cfg = self._graph.cfg
        with open(self.dump_prefix.get() + '_failing_interaction_syscalls.txt', 'w') as f:
            for inst, interactionData in MissingInteractions.missing.items():
                f.write(f"{inst}:\n")
                for abb in interactionData.abb_list:
                    f.write(f"\t{cfg.vp.files[abb][0]}:{cfg.vp.lines[abb][0]}\n")
                f.write("\n")

    def run(self):
        output_dict = {"instances": {"type": {}},
                       "interactions": {"to_instance_type": {},
                                        "accumulate_number_field": {"to_instance_type": {}}}, # handle number edge property for this data
                      }

        def create_interaction_key(interaction: str):
            interaction_value = {"found": 0}
            if MissingInteractions.in_use:
                interaction_value = {"found": 0, "missing": 0, "missing_imprecise": 0}
            output_dict["interactions"]["to_instance_type"][interaction] = interaction_value.copy()
            output_dict["interactions"]["accumulate_number_field"]["to_instance_type"][interaction] = interaction_value.copy()

        def assert_instance_registered(instance: str):
            assert instance in output_dict["interactions"]["to_instance_type"]
            assert instance in output_dict["interactions"]["accumulate_number_field"]["to_instance_type"]

        # Instances
        instances = self._graph.instances
        for instance in instances.vertices():
            inst_obj = instances.vp.obj[instance]
            inst_type_str = type(inst_obj).__name__
            if inst_type_str in output_dict["instances"]["type"]:
                output_dict["instances"]["type"][inst_type_str]["found"] += 1
                assert inst_type_str in output_dict["interactions"]["to_instance_type"]
                assert inst_type_str in output_dict["interactions"]["accumulate_number_field"]["to_instance_type"]
            else:
                output_dict["instances"]["type"][inst_type_str] = {"found": 1}
                create_interaction_key(inst_type_str)
        # Add missing instances of MissingInteractions data:
        if MissingInteractions.in_use:
            for inst in MissingInteractions.missing.keys():
                if inst not in output_dict["instances"]["type"]:
                    self._log.debug(f"instance type in MissingInteractions.missing that is not in the instance graph: {inst}")
                    create_interaction_key(inst)

        # found Interactions
        for edge in instances.edges():
            # Filter special edge types like "same_symbol_than" in Zephyr
            if self._get_edge_type_str(instances.ep.type[edge]) not in ["interaction", "create", "interaction_error"]:
                continue
            number_prop = instances.ep.number[edge]
            assert number_prop >= 1
            target = instances.vp.obj[edge.target()]
            target_type_str = type(target).__name__
            assert target_type_str in output_dict["instances"]["type"]
            assert_instance_registered(target_type_str)
            output_dict["interactions"]["to_instance_type"][target_type_str]["found"] += 1
            output_dict["interactions"]["accumulate_number_field"]["to_instance_type"][target_type_str]["found"] += number_prop

        # missing Interactions
        if MissingInteractions.in_use:
            for inst, interactionData in MissingInteractions.missing.items():
                assert_instance_registered(inst)
                output_dict["interactions"]["to_instance_type"][inst]["missing"] = interactionData.normal.count
                output_dict["interactions"]["accumulate_number_field"]["to_instance_type"][inst]["missing"] = interactionData.normal.count_without_edge_filter
                output_dict["interactions"]["to_instance_type"][inst]["missing_imprecise"] = interactionData.imprecise.count
                output_dict["interactions"]["accumulate_number_field"]["to_instance_type"][inst]["missing_imprecise"] = interactionData.imprecise.count_without_edge_filter
            # undetected missing interactions:
            output_dict["interactions"]["undetected"] = MissingInteractions.undetected

        # complete data
        output_dict["instances"]["num"] = instances.num_vertices()
        output_dict["interactions"]["num"] = instances.num_edges()

        self._log.info(f"Collected data: {output_dict}")

        if self.dump.get():
            with open(self.dump_prefix.get() + '.json', 'w') as f:
                json.dump(output_dict, f, indent=4)
            if MissingInteractions.in_use:
                self._write_failing_interaction_syscalls_to_file()
