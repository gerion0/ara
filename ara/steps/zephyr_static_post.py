import graph_tool.util
from ara.graph import Graph
from .step import Step
from pydoc import locate
from ara.os.zephyr import ZephyrInstance, Thread, ISR, ZephyrKernel, ZEPHYR
from .option import Option, String
from ara.util import KConfigFile

class ZephyrStaticPost(Step):
    """Deserializes the dictionary encoded instance objects generated by the ZephyrStatic step."""

    input_file = Option(name="input_file",
                         help="The input file",
                         ty=String())

    def get_single_dependencies(self):
        return ["ZephyrStatic", "LLVMMap"]

    @staticmethod
    def create_static_instance(instances, label: str, obj: ZephyrInstance, ident: str, sched_on: bool):
        v = instances.add_vertex()
        instances.vp.label[v] = label
        instances.vp.obj[v] = obj
        instances.vp.id[v] = ident
        # Static instances are always unique since they are properly initialized globals
        instances.vp.branch[v] = False
        instances.vp.loop[v] = False
        instances.vp.after_scheduler[v] = sched_on
        instances.vp.unique[v] = True

        # There are no sensible defaults for those yet.
        # TODO: Use something other than abb zero for static instances.
        instances.vp.soc[v] = 0
        instances.vp.llvm_soc[v] = 0
        instances.vp.file[v] = ""
        instances.vp.line[v] = 0
        instances.vp.specialization_level[v] = ""
        return v

    def run(self):
        assert self._graph.instances is not None

        ZEPHYR.config = KConfigFile(self.input_file.get()[:-3] + '.config')

        duplicate_instances = []
        for instance in self._graph.instances.vertices():
            vals = self._graph.instances.vp.obj[instance]
            instance_type = locate('ara.os.zephyr.' + self._graph.instances.vp.label[instance])
            if instance_type is Thread or instance_type is ISR:
                # Fill out the entry abb because it is easier in python than in c++.
                # Skip instance creation if we already have an instance with the same entry point.
                entry_abb = self._graph.cfg.get_entry_abb(self._graph.cfg.get_function_by_name(vals['entry_name']))
                clone = ZEPHYR.explored_entry_points.get(entry_abb)
                if clone != None:
                    self._graph.instances.vp.unique[clone] = False
                    duplicate_instances.append(instance)
                    continue
                vals['entry_abb'] = entry_abb

            inst = instance_type(**vals)
            if inst.has_entry():
                ZEPHYR.explored_entry_points[inst.entry_abb] = instance

            # Mark the ids of all static instances as used. Since we use symbol names we know
            # them to be unique
            ZEPHYR.id_count[self._graph.instances.vp.id[instance]] = 1
            self._graph.instances.vp.obj[instance] = inst

        for v in duplicate_instances:
            self._graph.instances.remove_vertex(v)

        # If there is a main, also add a thread for that.
        # Also, there is no matching abb to give to the vertex
        # NOTE: main() can not be the entry point of a second normal thread because the signature
        # does not match
        main = graph_tool.util.find_vertex(self._graph.cfg, self._graph.cfg.vp['name'], 'main')
        if len(main) == 1:
            main_entry_abb = self._graph.cfg.get_entry_abb(main[0])
            prio = int(ZEPHYR.config['CONFIG_MAIN_THREAD_PRIORITY'])
            stack_size = int(ZEPHYR.config['CONFIG_MAIN_STACK_SIZE'])
            main_thread = Thread(None, None, stack_size, None, "main", main_entry_abb, (None, None, None), prio, 0, 0)
            ZephyrStaticPost.create_static_instance(self._graph.instances, "Main", main_thread, "__main", True)

        # Create a unique node for the Zephyr kernel.
        kernel = ZephyrKernel(int(ZEPHYR.config['CONFIG_HEAP_MEM_POOL_SIZE']))
        ZEPHYR.kernel = ZephyrStaticPost.create_static_instance(self._graph.instances, "Zephyr", kernel, "__kernel", False)

